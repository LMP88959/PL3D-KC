/*****************************************************************************/
/*
 * PiSHi LE (Lite edition) - Fundamentals of the King's Crook graphics engine.
 * 
 *   by EMMIR 2018-2022
 *   
 *   YouTube: https://www.youtube.com/c/LMP88
 *   
 * This software is released into the public domain.
 */
/*****************************************************************************/

#include "pl.h"

/*  importer.c
 * 
 * Code for importing DMDL files used in King's Crook.
 * DMDL files can be generated by making models in the
 * Freeform Model Editor (mdlrfree)
 * 
 */

#include <stdio.h>
#include <stdlib.h>

static char *cur_fn = NULL;

static char g_buf[1024];

static void
read_line(FILE *out, char *buf, int len)
{
	if (!fgets(buf, len, out)) {
		fprintf(stderr, "invalid dmdl file: %s\n", cur_fn);
		fclose(out);
		getchar();
		exit(0);
	}
}

static void
read_polygon(FILE *out, struct PL_POLY *dst)
{
    int tmp; /* texture ID (ignored for this simple importer) */
    int i, nv;
    int ctr = 0;
    
	read_line(out, g_buf, 16);
	sscanf(g_buf, "%d", &tmp);
    dst->tex = NULL;
	read_line(out, g_buf, 16);
	sscanf(g_buf, "%d", &dst->color);
	read_line(out, g_buf, 16);
	read_line(out, g_buf, 16);
	sscanf(g_buf, "%d", &dst->n_verts);
	dst->n_verts &= 0xf;
	nv = ((dst->n_verts & 0xf) + 1) * 4;
	for (i = 0; i < nv; i++) {
        read_line(out, g_buf, 16);
	    if ((i % 4) != 1) {
	        sscanf(g_buf, "%d\n", &dst->verts[ctr]);
	        ctr++;
	    }
	}
}

extern int
import_dmdl(char *name, struct PL_OBJ **o)
{    
    struct PL_OBJ *dst;
	FILE *out;
    int i, tmp;
    int x, y, z;
    int *dv;

	snprintf(g_buf, sizeof(g_buf), "%s.dmdl", name);
	cur_fn = name;
	if (!(out = fopen(g_buf, "rb"))) {
		fprintf(stderr, "failed to read dmdl file: %s\n", g_buf);
		return 0;
	}
	*o = EXT_calloc(1, sizeof(struct PL_OBJ));
	dst = *o;
	read_line(out, g_buf, 256);
	sscanf(g_buf, "%d", &dst->n_verts);
	
	dst->verts = EXT_calloc(1, dst->n_verts * PL_VLEN * sizeof(int));
	if (dst->verts == NULL) {
        EXT_error(PL_ERR_NO_MEM, "importer", "no memory");
		return 0;
	}
	for (i = 0; i < dst->n_verts; i++) {
		read_line(out, g_buf, 256);
		dv = dst->verts;
		x = i * PL_VLEN + 0;
        y = i * PL_VLEN + 1;
        z = i * PL_VLEN + 2;
		/* w coord is really unused */
		sscanf(g_buf, "%d %d %d %d", &dv[x], &dv[y], &dv[z], &tmp);
	}

	read_line(out, g_buf, 256);
	sscanf(g_buf, "%d", &dst->n_polys);
	
	dst->polys = EXT_calloc(1, dst->n_polys * sizeof(struct PL_POLY));
	if (dst->polys == NULL) {
		EXT_error(PL_ERR_NO_MEM, "importer", "no memory");
		return 0;
	}
	for (i = 0; i < dst->n_polys; i++) {
		read_polygon(out, &dst->polys[i]);
	}
	fclose(out);

	return 1;
}
